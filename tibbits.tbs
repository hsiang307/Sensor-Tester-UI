include "global.tbh"

#define DELAY_50MS (5)

const TBT28_INIT_SIGNATURE=&h5982
const TBT28_STAMP="TBT28> "
const TBT28_CR_LF=chr(13)+chr(10)
const TBT28_WRITE_ADDR=&h46		' address code for write
const TBT28_READ_ADDR=&h47		' address code for read
const TBT28_CMD_POWER_DOWN		=&h00
const TBT28_CMD_POWER_ON		=&h01
const TBT28_CMD_AUTO_RESOL_0	=&h10
const TBT28_CMD_HRESOL_0		=&h12
const TBT28_CMD_LRESOL_0		=&h13



declare sub tbt28_cmd_send(cmd as byte)
declare sub tbt28_delay_msecond(value as word)
dim i2c_num_tbt28 as byte
dim tbt28_init_flag as word

const TBT29_INIT_SIGNATURE=&hF083
const TBT29_STAMP="TBT29> "
const TBT29_CR_LF=chr(13)+chr(10)
const TBT29_MFG_ID	=&h54
const TBT29_DEVID		=&h400
const TBT29_WRITE_ADDR=&h30
const TBT29_READ_ADDR=&h31
enum tbt29_resolution
	TBT29_RESOLUSION_MODE_1=&h01  '0.25C (tCONV = 65 ms typical)
end enum
enum tbt29_regs
	TBT29_REG_TA=&h05,
	TBT29_REG_MFGID=&h06,
	TBT29_REG_IDREV=&h07,
	TBT29_REG_RESOL=&h08
end enum
declare function tbt29_read_data(op as tbt29_regs) as word
declare sub tbt29_write_data(op as tbt29_regs,data as word)
declare sub tbt29_delay_msecond(value as word)
dim i2c_num_tbt29 as byte
dim tbt29_init_flag as word


const TBT30_INIT_SIGNATURE=&h3969
const TBT30_STAMP="TBT30> "
const TBT30_CR_LF=chr(13)+chr(10)
const TBT30_WRITE_ADDR=&h4E
const TBT30_READ_ADDR=&h4F
enum tbt30_status
	TBT30_STATUS_NORMAL_OPERATION=&h0,
	TBT30_STAUTS_STALE_DATA=&h1,
	TBT30_STAUTS_IN_COMMAND_MODE=&h2,
	TBT30_STAUTS_NOT_USED=&h3
end enum


declare sub tbt30_delay_msecond(value as word)
dim i2c_num_tbt30 as byte
dim tbt30_init_flag as word

const TBT35_INIT_SIGNATURE=&h10FE
const TBT35_STAMP="TBT35>"
const TBT35_CR_LF=chr(13)+chr(10)

const TBT35_WRITE_ADDR=&hC0			' Manufacturer address code for write
const TBT35_READ_ADDR =&hC1			' Manufacturer address code for read

const TBT35_CMD_READ_PRESSURE		=&h00
const TBT35_CMD_READ_COEFFICIENT	=&h04
const TBT35_CMD_START_CONVERSION	=&h12

declare sub tbt35_delay_msecond(value as word)

dim i2c_num_tbt35 as byte
dim tbt35_init_flag as word
dim a0,b1,b2,c12 as float=0

'====================================================================
function tbt28_init(use_ssi as no_yes)as ok_ng
'Call this function to initialize the Tibbit.
'Use_ssi argument specifies whether you want to communicate with this Tibbit using the SSI channel running in the I2C mode (YES), or
'go for direct I/O manipulation a.k.a. bit-banging (NO).
'Note that there is a limited number of SSI channels so if you set use_ssi=YES this function may return NG, meaning that
'there are no free SSI channels left. This doesn't mean failure. Rather, it means that comms will proceed in bit banging mood.
	
	tbt28_init=OK
	tbt28_init_flag=TBT28_INIT_SIGNATURE

	i2c_num_tbt28=si2c_register("TBT28", TBT28_DATA_PIN, TBT28_CLK_PIN, use_ssi)

	si2c_get(i2c_num_tbt28)

	if i2c_num_tbt28<=3 then
		ssi.channel=i2c_num_tbt28
		ssi.enabled=NO
		ssi.baudrate=100
		ssi.clkmap=TBT28_CLK_PIN
		ssi.dimap=TBT28_DATA_PIN
		ssi.domap=TBT28_DATA_PIN
		ssi.direction=PL_SSI_DIRECTION_LEFT
		ssi.zmode=PL_SSI_ZMODE_ENABLED_ON_ZERO
		ssi.mode=PL_SSI_MODE_0
		ssi.enabled=YES
	else
		if use_ssi=YES then
			tbt28_init=NG
		end if
	end if

	'Switch sensor to power down mode
	tbt28_cmd_send(TBT28_CMD_POWER_DOWN)

	'Switch sensor to power on mode
	tbt28_cmd_send(TBT28_CMD_POWER_ON)

	'Switch sensor to high resolution mode
	tbt28_cmd_send(TBT28_CMD_HRESOL_0)

	'Wait to complete 1st Auto-resolution mode measurement.(max. 180 ms)
	tbt28_delay_msecond(DELAY_50MS+DELAY_50MS+DELAY_50MS)

	if tbt28_get()=65535 then
		tbt28_init=NG
	end if
	
end function

function tbt28_get() as word
'Returns a 16-bit number expressing relative ambient light intensity.
	dim upper,lower as byte
	tbt28_get=0
	if tbt28_init_flag<> TBT28_INIT_SIGNATURE then
		exit function
	end if
	si2c_get(i2c_num_tbt28)
	si2c_start()
	si2c_write(TBT28_READ_ADDR)
	upper=si2c_read(true)
	lower=si2c_read(false)
	si2c_stop()
	tbt28_get=upper*256+lower
end function

sub tbt28_cmd_send(cmd as byte)
	si2c_start()
	si2c_write(TBT28_WRITE_ADDR)
	si2c_write(cmd)
	si2c_stop()
end sub

sub tbt28_delay_msecond(value as word)
	sys.timercountms=0
	while sys.timercountms<value
	wend
end sub

function tbt29_init(use_ssi as no_yes) as errcheck
'Call this function to initialize the Tibbit.
'Use_ssi argument specifies whether you want to communicate with this Tibbit using the SSI channel running in the I2C mode (YES), or
'go for direct I/O manipulation a.k.a. bit-banging (NO).
'Note that there is a limited number of SSI channels so if you set use_ssi=YES this function may return TBT29_NO_SSI_AVAILABLE, meaning that
'there are no free SSI channels left. This doesn't mean failure. Rather, it means that comms will proceed in bit banging mood.
'Other error codes (TBT29_WRONG_MFGID and TBT29_WRONG_DEVID_REVISION) indicate failure.

	tbt29_init=TBT29_OK
	tbt29_init_flag=TBT29_INIT_SIGNATURE
	i2c_num_tbt29=si2c_register("TBT29", TBT29_DATA_PIN, TBT29_CLK_PIN,use_ssi)

	if i2c_num_tbt29 <4 then
		ssi.channel=i2c_num_tbt29
		ssi.enabled=NO
		ssi.baudrate=100
		ssi.clkmap=TBT29_CLK_PIN
		ssi.dimap=TBT29_DATA_PIN
		ssi.domap=TBT29_DATA_PIN
		ssi.direction=PL_SSI_DIRECTION_LEFT
		ssi.mode=PL_SSI_MODE_2
		ssi.zmode=PL_SSI_ZMODE_ENABLED_ON_ZERO
		ssi.enabled=YES
	else
		tbt29_init=TBT29_NO_SSI_AVAILABLE
	end if

	'check the TBT29_MFG_ID
	if tbt29_read_data(TBT29_REG_MFGID)<>TBT29_MFG_ID then
		tbt29_init=TBT29_WRONG_MFGID
		goto leave
	end if

	'check the TBT29_DEVID+MCP9808_DEFAULT_REVISION
	if tbt29_read_data(TBT29_REG_IDREV)<>TBT29_DEVID then
		tbt29_init=TBT29_WRONG_DEVID_REVISION
		goto leave
	end if

	'resolution :+0.25 C (tCONV = 65 ms typical)
	tbt29_write_data(TBT29_REG_RESOL,TBT29_RESOLUSION_MODE_1)
leave:

end function

function tbt29_get_c() as real
'Returns the signed floating point value expressing the temperature in deg. C.
	tbt29_get_c=tbt29_get()
	tbt29_get_c=tbt29_get_c/4
end function


function tbt29_get() as integer
'Returns the signed integer value expressing the temperature in 0.25 deg. C steps.	

	const DELAY_IN_65_MS=7
	dim r as word
	dim t_integer as word
	dim t_fraction as byte
	
	if tbt29_init_flag<>TBT29_INIT_SIGNATURE then

		exit function
	end if

	si2c_get(i2c_num_tbt29) 

	tbt29_delay_msecond(DELAY_IN_65_MS)

	r=tbt29_read_data(TBT29_REG_TA)

	if r and &h1000 then
		'temperature is negative
		t_integer=(r and &h0FFF)/16
		t_fraction=(r and &h000F)/4
		tbt29_get=1024-((t_integer*4)+t_fraction)
	else	
		'temperature is positive
		t_integer=(r and &h0FFF)/16
		t_fraction=(r and &h000F)/4
		tbt29_get=(t_integer*4)+t_fraction
	end if
end function

function tbt29_read_data(op as tbt29_regs) as word
	dim upper,lower as byte=0

	upper=0
	lower=0
	si2c_get(i2c_num_tbt29)
	si2c_start()

	'send address + op
	si2c_write(TBT29_WRITE_ADDR)
	si2c_write(op)
	
	si2c_start()

	si2c_write(TBT29_READ_ADDR)

	if op=TBT29_REG_RESOL then
		lower=si2c_read(true)
	else
		upper=si2c_read(true)
		lower=si2c_read(false)
	end if

	si2c_stop()
	tbt29_read_data=upper*256+lower
end function

sub tbt29_write_data(op as tbt29_regs,data as word)
	dim value as byte
	si2c_get(i2c_num_tbt29) 
	si2c_start()

	si2c_write(TBT29_WRITE_ADDR)
	si2c_write(op)

	if op=TBT29_REG_RESOL then
		value=data and &h00FF
		si2c_write(value)
	else
		value=(data and &hFF00)/256
		si2c_write(value)
		value=data and &h00FF
		si2c_write(value)		
	end if	
	si2c_stop()
end sub

sub tbt29_delay_msecond(value as word)

	sys.timercountms=0
	while sys.timercountms<value
	wend

end sub

function tbt30_init(use_ssi as no_yes) as ok_ng
'Call this function to initialize the Tibbit.
'Use_ssi argument specifies whether you want to communicate with this Tibbit using the SSI channel running in the I2C mode (YES), or
'go for direct I/O manipulation a.k.a. bit-banging (NO).
'Note that there is a limited number of SSI channels so if you set use_ssi=YES this function may return NG, meaning that
'there are no free SSI channels left. This doesn't mean failure. Rather, it means that comms will proceed in bit banging mood.

	tbt30_init=OK
	
	#if TBT30_DEBUG_PRINT=1
		tbt30_debug_print("++++++++++")
	#endif

	tbt30_init_flag=TBT30_INIT_SIGNATURE
	i2c_num_tbt30=si2c_register("TBT30", TBT30_DATA_PIN, TBT30_CLK_PIN,use_ssi)

	#if TBT30_DEBUG_PRINT=1
		tbt30_debug_print("i2c num: "+str(i2c_num_tbt30))
	#endif
	if i2c_num_tbt30<4 then
		ssi.channel=i2c_num_tbt30
		ssi.enabled=NO
		ssi.baudrate=50
		ssi.clkmap=TBT30_CLK_PIN
		ssi.dimap=TBT30_DATA_PIN
		ssi.domap=TBT30_DATA_PIN
		ssi.direction=PL_SSI_DIRECTION_LEFT
		ssi.mode=PL_SSI_MODE_2
		ssi.zmode=PL_SSI_ZMODE_ENABLED_ON_ZERO
		ssi.enabled=YES
	end if

	#if TBT30_DEBUG_PRINT=1
		tbt30_debug_print("----------")
	#endif
	
	dim t,h as float

	if tbt30_get_pc(h,t)<>OK then
		tbt30_init=NG
	end if	
	
end function

function tbt30_get_pc(byref humidity as float, byref temperature as float) as ok_ng
'Returns "real" humidity and temperature data expressed in %PH and degrees C.
'NOTE: this call may fail, so check the ON/NG status returned by the function.
	
	tbt30_get_pc=OK
	
	dim temp,hum as word
	
	tbt30_get_pc=tbt30_get(hum,temp)
	
	humidity=hum
	humidity=(humidity*100)/16383

	temperature=temp
	temperature=temperature/16383
	temperature=temperature*165
	temperature=temperature-40
	
	if humidity=100 then
		tbt30_get_pc=NG
	end if
	
end function

function tbt30_get(byref humidity as word, byref temperature as word)as ok_ng
'Returns humidity and temperature data expressed as 16-bit unsigned values.
'See how the conversion into "real" values is done in tbt30_get_pc().
'NOTE: this call may fail, so check the ON/NG status returned by the function.

	dim status as tbt30_status
	dim data1,data2,data3,data4,tmp1,hi,lo,temp2 as byte
	
	if tbt30_init_flag<>TBT30_INIT_SIGNATURE then
	
		exit function
	end if

	tbt30_get=OK

	si2c_get(i2c_num_tbt30)

	'send the measurement request
	si2c_start()
	si2c_write(TBT30_WRITE_ADDR)
	si2c_stop()

	tbt30_delay_msecond(DELAY_50MS)

	'fetch humidity data
	si2c_start()
	si2c_write(TBT30_READ_ADDR)
	data1=si2c_read(true)
	data2=si2c_read(true)
	data3=si2c_read(true)
	data4=si2c_read(false)
	si2c_stop()

	status=data1 and &h80
	status=status/128
	status=(status and &h40)/64


	select case status
	case TBT30_STATUS_NORMAL_OPERATION:

	case TBT30_STAUTS_STALE_DATA:

	case TBT30_STAUTS_IN_COMMAND_MODE:

		tbt30_get=NG
		exit function
	case TBT30_STAUTS_NOT_USED:

		tbt30_get=NG
		exit function
	case else:
	end select

	'humidity:   Data1 [13:6] + Data2 [7:0]
	'temerature: Data3 [13:6] + Data4 [5:0]
	tmp1=data1*4
	humidity=tmp1*64+data2
	


	tmp1=data3*4
	tmp1=tmp1/16
	hi=data3/64*16
	hi=hi+tmp1

	tmp1=data3 and &h03
	tmp1=tmp1*64
	
	temp2=data4 and &hC0
	temp2=temp2/4
	lo=tmp1+temp2

	tmp1=data4 and &h3C
	tmp1=tmp1/4
	lo=lo+tmp1

	temperature=hi*256+lo
	
end function

sub tbt30_delay_msecond(value as word)

	sys.timercountms=0
	while sys.timercountms<value
	wend

end sub

function tbt35_init(use_ssi as no_yes) as ok_ng
'Call this function to initialize the Tibbit.
'Use_ssi argument specifies whether you want to communicate with this Tibbit using the SSI channel running in the I2C mode (YES), or
'go for direct I/O manipulation a.k.a. bit-banging (NO).
'Note that there is a limited number of SSI channels so if you set use_ssi=YES this function may return NG, meaning that
'there are no free SSI channels left. This doesn't mean failure. Rather, it means that comms will proceed in bit banging mood.
	dim tmp as byte
	dim a0_tmp,b1_tmp,b2_tmp,c12_tmp,tmp2 as word

	tbt35_init=OK

	tbt35_init_flag=TBT35_INIT_SIGNATURE
	i2c_num_tbt35=si2c_register("TBT35", TBT35_DATA_PIN, TBT35_CLK_PIN,use_ssi)

	#if TBT35_DEBUG_PRINT=1
		tbt35_debug_print("i2c num: "+str(i2c_num_tbt35))
	#endif

	if i2c_num_tbt35<4 then
		ssi.channel=i2c_num_tbt35
		ssi.enabled=NO
		ssi.baudrate=1
		ssi.clkmap=TBT35_CLK_PIN
		ssi.dimap=TBT35_DATA_PIN
		ssi.domap=TBT35_DATA_PIN
		ssi.direction=PL_SSI_DIRECTION_LEFT
		ssi.mode=PL_SSI_MODE_2
		ssi.zmode=PL_SSI_ZMODE_ENABLED_ON_ZERO
		ssi.enabled=YES
	else
		if use_ssi=YES then
			tbt35_init=NG
		end if
	end if

	si2c_get(i2c_num_tbt35)

	si2c_start()

	si2c_write(TBT35_WRITE_ADDR)
	si2c_write(TBT35_CMD_READ_COEFFICIENT)

	si2c_start()

	si2c_write(TBT35_READ_ADDR)

	'a0
	tmp=si2c_read(true)
	a0_tmp=tmp*256
	tmp=si2c_read(true)
	a0_tmp=a0_tmp+tmp

	'b1
	tmp=si2c_read(true)
	b1_tmp=tmp*256
	tmp=si2c_read(true)
	b1_tmp=b1_tmp+tmp

	'b2
	tmp=si2c_read(true)
	b2_tmp=tmp*256
	tmp=si2c_read(true)
	b2_tmp=b2_tmp+tmp

	'c12
	tmp=si2c_read(true)
	c12_tmp=tmp*256
	tmp=si2c_read(false)
	c12_tmp=c12_tmp+tmp
	si2c_stop()

	'a0 :signed, integer bits=12,fractional bits=3
	a0=a0_tmp and &h7FF8
	a0=a0/8

	tmp2=a0_tmp and &h0007
	'Negative coefficients are coded in 2's complement notation
	if a0_tmp and &h8000 then
		a0=4095-a0
		tmp2=&h7-a0_tmp
	end if
	'f2
	if tmp2 and &h04 then
		a0=a0+0.5
	end if
	'f1
	if tmp2 and &h02 then
		a0=a0+0.25
	end if
	'f0
	if tmp2 and &h01 then
		a0=a0+0.125
	end if
	
	if a0_tmp and &h8000 then
		a0=-a0
	end if

	'b1	:signed, integer bits=2,fractional bits=13
	b1=b1_tmp and &h6000
	b1=b1/8192
	tmp2=b1_tmp and &h1FFF

	'Negative coefficients are coded in 2's complement notation
	if b1_tmp and &h8000 then
		b1=3-b1
		tmp2= &h1FFF-b1_tmp
	end if
	'f12
	if tmp2 and &h1000 then
		b1=b1+0.5
	end if
	'f11
	if tmp2 and &h800 then
		b1=b1+0.25
	end if
	'f10
	if tmp2 and &h400 then
		b1=b1+0.125
	end if
	'f9
	if tmp2 and &h200 then
		b1=b1+0.0625
	end if
	'f8
	if tmp2 and &h100 then
		b1=b1+0.03125
	end if
	'f7
	if tmp2 and &h80 then
		b1=b1+0.015625
	end if
	'f6
	if tmp2 and &h40 then
		b1=b1+0.0078125
	end if
	'f5
	if tmp2 and &h20 then
		b1=b1+0.00390625
	end if
	'f4
	if tmp2 and &h10 then
		b1=b1+0.001953125
	end if
	'f3
	if tmp2 and &h08 then
		b1=b1+0.0009765625
	end if
	'f2
	if tmp2 and &h04 then
		b1=b1+0.00048828125
	end if
	'f1
	if tmp2 and &h02 then
		b1=b1+0.000244140625
	end if
	'f0
	if tmp2 and &h01 then
		b1=b1+0.0001220703125
	end if

	if b1_tmp and &h8000 then
		b1=-b1
	end if

	'b2	:signed, integer bits=1,fractional bits=14
	b2=b2_tmp and &h4000
	b2=b2/16384
	tmp2=b2_tmp and &h3FFF

	'Negative coefficients are coded in 2's complement notation
	if b2_tmp and &h8000 then
		b2=1-b2
		tmp2=&h3FFF-b2_tmp
	end if

	'f13
	if tmp2 and &h2000 then
		b2=b2+0.5
	end if
	'f12
	if tmp2 and &h1000 then
		b2=b2+0.25
	end if
	'f11
	if tmp2 and &h800 then
		b2=b2+0.125
	end if
	'f10
	if tmp2 and &h400 then
		b2=b2+0.0625
	end if
	'f9
	if tmp2 and &h200 then
		b2=b2+0.03125
	end if
	'f8
	if tmp2 and &h100 then
		b2=b2+0.015625
	end if
	'f7
	if tmp2 and &h80 then
		b2=b2+0.0078125
	end if
	'f6
	if tmp2 and &h40 then
		b2=b2+0.00390625
	end if
	'f5
	if tmp2 and &h20 then
		b2=b2+0.001953125
	end if
	'f4
	if tmp2 and &h10 then
		b2=b2+0.0009765625
	end if
	'f3
	if tmp2 and &h08 then
		b2=b2+0.00048828125
	end if
	'f2
	if tmp2 and &h04 then
		b2=b2+0.000244140625
	end if
	'f1
	if tmp2 and &h02 then
		b2=b2+0.0001220703125
	end if
	'f0
	if tmp2 and &h01 then
		b2=b2+0.00006103515625
	end if

	if b2_tmp and &h8000 then
		b2=-b2
	end if

	'c12;signed, integer bits=0,fractional bits=13,dec pt zero pad=9
	tmp2=c12_tmp /4
	tmp2=tmp2 and &h1FFF

	'Negative coefficients are coded in 2's complement notation
	if c12_tmp and &h8000 then
		c12=-c12
		tmp2=&h1FFF-b2_tmp
	end if

	c12=0.0
	'f12
	if tmp2 and &h1000 then
		c12=c12+0.0009765625
	end if
	'f11
	if tmp2 and &h800 then
		c12=c12+0.00048828125
	end if
	'f10
	if tmp2 and &h400 then
		c12=c12+0.000244140625
	end if
	'f9
	if tmp2 and &h200 then
		c12=c12+0.0001220703125
	end if
	'f8
	if tmp2 and &h100 then
		c12=c12+0.00006103515625
	end if
	'f7
	if tmp2 and &h80 then
		c12=c12+0.000030517578125
	end if
	'f6
	if tmp2 and &h40 then
		c12=c12+0.0000152587890625
	end if
	'f5
	if tmp2 and &h20 then
		c12=c12+0.00000762939453125
	end if
	'f4
	if tmp2 and &h10 then
		c12=c12+0.000003814697265625
	end if
	'f3
	if tmp2 and &h08 then
		c12=c12+0.0000019073486328125
	end if
	'f2
	if tmp2 and &h04 then
		c12=c12+0.00000095367431640625
	end if
	'f1
	if tmp2 and &h02 then
		c12=c12+0.000000476837158203125
	end if
	'f0
	if tmp2 and &h01 then
		c12=c12+0.0000002384185791015625
	end if

	if c12_tmp and &h8000 then
		c12=-c12
	end if
	
	if tbt35_get_kpa()=50 then
		tbt35_init=NG
	end if

end function

function tbt35_get() as word
'Returns the word value expressing the pressure in 10 Pa steps.
	tbt35_get=tbt35_get_kpa()*100
end function


function tbt35_get_kpa()as float
'Returns the floating point value expressing the pressure in kPa.
	dim tmp as byte
	dim padc,tadc as word=0
	dim c12x2,a1,a1x1,y1,a2x2,pcomp as float

	if tbt35_init_flag<>TBT35_INIT_SIGNATURE then
	#if TBT35_DEBUG_PRINT=1
		tbt35_debug_print("The lib is not initialized, call tbt35_init() first")
	#endif
		exit function
	end if

	si2c_get(i2c_num_tbt35)

	si2c_start()
	si2c_write(TBT35_WRITE_ADDR)
	si2c_write(TBT35_CMD_START_CONVERSION)
	si2c_write(&h00)
	si2c_stop()

	'Time between start convert command and data available in the Pressure and Temperature registers
	#if PLATFORM_TYPE_32
		tbt35_delay_msecond(1)
	#else
		tbt35_delay_msecond(3)
	#endif

	si2c_start()

	si2c_write(TBT35_WRITE_ADDR)
	si2c_write(TBT35_CMD_READ_PRESSURE)

	si2c_start()
	si2c_write(TBT35_READ_ADDR)

	'pressure
	tmp=si2c_read(true)
	padc=tmp*256
	tmp=si2c_read(true)
	padc=padc+tmp

	'temprature
	tmp=si2c_read(true)
	tadc=tmp*256
	tmp=si2c_read(false)
	tadc=tadc+tmp

	si2c_stop()

	padc=padc /64
	tadc=tadc /64

	'Pcomp = a0 + (b1 + c12 .Tadc) . Padc + b2 . Tadc
	c12x2=c12*tadc
	a1=b1+c12x2
	a1x1=a1*padc
	y1=a0+a1x1
	a2x2=b2*tadc
	pcomp=y1+a2x2
	
	'kpa=pcomp*(115-50)/1023 +50
	tbt35_get_kpa=pcomp*(115-50)/1023+50

	#if TBT35_DEBUG_PRINT=1
		tbt35_debug_print("padc/tadc"+str(padc)+"/"+str(tadc))
	#endif	
end function

sub tbt35_delay_msecond(value as word)
	dim ax,bx as word
		sys.timercountms=0
		while sys.timercountms<value
		wend
end sub


