include "global.tbh"

#define DELAY_50MS (5)

const TBT28_INIT_SIGNATURE=&h5982
const TBT28_STAMP="TBT28> "
const TBT28_CR_LF=chr(13)+chr(10)
const TBT28_WRITE_ADDR=&h46		' address code for write
const TBT28_READ_ADDR=&h47		' address code for read
const TBT28_CMD_POWER_DOWN		=&h00
const TBT28_CMD_POWER_ON		=&h01
const TBT28_CMD_AUTO_RESOL_0	=&h10
const TBT28_CMD_HRESOL_0		=&h12
const TBT28_CMD_LRESOL_0		=&h13
declare sub tbt28_cmd_send(cmd as byte)
declare sub tbt28_delay_msecond(value as word)
dim i2c_num_tbt28 as byte
dim tbt28_init_flag as word

const TBT29_INIT_SIGNATURE=&hF083
const TBT29_STAMP="TBT29> "
const TBT29_CR_LF=chr(13)+chr(10)
const TBT29_MFG_ID	=&h54
const TBT29_DEVID		=&h400
const TBT29_WRITE_ADDR=&h30
const TBT29_READ_ADDR=&h31
enum tbt29_resolution
	TBT29_RESOLUSION_MODE_1=&h01  '0.25C (tCONV = 65 ms typical)
end enum
enum tbt29_regs
	TBT29_REG_TA=&h05,
	TBT29_REG_MFGID=&h06,
	TBT29_REG_IDREV=&h07,
	TBT29_REG_RESOL=&h08
end enum
declare function tbt29_read_data(op as tbt29_regs) as word
declare sub tbt29_write_data(op as tbt29_regs,data as word)
declare sub tbt29_delay_msecond(value as word)
dim i2c_num_tbt29 as byte
dim tbt29_init_flag as word

'====================================================================
function tbt28_init(use_ssi as no_yes)as ok_ng
'Call this function to initialize the Tibbit.
'Use_ssi argument specifies whether you want to communicate with this Tibbit using the SSI channel running in the I2C mode (YES), or
'go for direct I/O manipulation a.k.a. bit-banging (NO).
'Note that there is a limited number of SSI channels so if you set use_ssi=YES this function may return NG, meaning that
'there are no free SSI channels left. This doesn't mean failure. Rather, it means that comms will proceed in bit banging mood.
	
	tbt28_init=OK
	tbt28_init_flag=TBT28_INIT_SIGNATURE

	i2c_num_tbt28=si2c_register("TBT28", TBT28_DATA_PIN, TBT28_CLK_PIN, use_ssi)

	si2c_get(i2c_num_tbt28)

	if i2c_num_tbt28<=3 then
		ssi.channel=i2c_num_tbt28
		ssi.enabled=NO
		ssi.baudrate=100
		ssi.clkmap=TBT28_CLK_PIN
		ssi.dimap=TBT28_DATA_PIN
		ssi.domap=TBT28_DATA_PIN
		ssi.direction=PL_SSI_DIRECTION_LEFT
		ssi.zmode=PL_SSI_ZMODE_ENABLED_ON_ZERO
		ssi.mode=PL_SSI_MODE_0
		ssi.enabled=YES
	else
		if use_ssi=YES then
			tbt28_init=NG
		end if
	end if

	'Switch sensor to power down mode
	tbt28_cmd_send(TBT28_CMD_POWER_DOWN)

	'Switch sensor to power on mode
	tbt28_cmd_send(TBT28_CMD_POWER_ON)

	'Switch sensor to high resolution mode
	tbt28_cmd_send(TBT28_CMD_HRESOL_0)

	'Wait to complete 1st Auto-resolution mode measurement.(max. 180 ms)
	tbt28_delay_msecond(DELAY_50MS+DELAY_50MS+DELAY_50MS)

	if tbt28_get()=65535 then
		tbt28_init=NG
	end if
	
end function

function tbt28_get() as word
'Returns a 16-bit number expressing relative ambient light intensity.
	dim upper,lower as byte
	tbt28_get=0
	if tbt28_init_flag<> TBT28_INIT_SIGNATURE then
		exit function
	end if
	si2c_get(i2c_num_tbt28)
	si2c_start()
	si2c_write(TBT28_READ_ADDR)
	upper=si2c_read(true)
	lower=si2c_read(false)
	si2c_stop()
	tbt28_get=upper*256+lower
end function

sub tbt28_cmd_send(cmd as byte)
	si2c_start()
	si2c_write(TBT28_WRITE_ADDR)
	si2c_write(cmd)
	si2c_stop()
end sub

sub tbt28_delay_msecond(value as word)
	sys.timercountms=0
	while sys.timercountms<value
	wend
end sub

function tbt29_init(use_ssi as no_yes) as errcheck
'Call this function to initialize the Tibbit.
'Use_ssi argument specifies whether you want to communicate with this Tibbit using the SSI channel running in the I2C mode (YES), or
'go for direct I/O manipulation a.k.a. bit-banging (NO).
'Note that there is a limited number of SSI channels so if you set use_ssi=YES this function may return TBT29_NO_SSI_AVAILABLE, meaning that
'there are no free SSI channels left. This doesn't mean failure. Rather, it means that comms will proceed in bit banging mood.
'Other error codes (TBT29_WRONG_MFGID and TBT29_WRONG_DEVID_REVISION) indicate failure.

	tbt29_init=TBT29_OK
	tbt29_init_flag=TBT29_INIT_SIGNATURE
	i2c_num_tbt29=si2c_register("TBT29", TBT29_DATA_PIN, TBT29_CLK_PIN,use_ssi)

	if i2c_num_tbt29 <4 then
		ssi.channel=i2c_num_tbt29
		ssi.enabled=NO
		ssi.baudrate=100
		ssi.clkmap=TBT29_CLK_PIN
		ssi.dimap=TBT29_DATA_PIN
		ssi.domap=TBT29_DATA_PIN
		ssi.direction=PL_SSI_DIRECTION_LEFT
		ssi.mode=PL_SSI_MODE_2
		ssi.zmode=PL_SSI_ZMODE_ENABLED_ON_ZERO
		ssi.enabled=YES
	else
		tbt29_init=TBT29_NO_SSI_AVAILABLE
	end if

	'check the TBT29_MFG_ID
	if tbt29_read_data(TBT29_REG_MFGID)<>TBT29_MFG_ID then
		tbt29_init=TBT29_WRONG_MFGID
		goto leave
	end if

	'check the TBT29_DEVID+MCP9808_DEFAULT_REVISION
	if tbt29_read_data(TBT29_REG_IDREV)<>TBT29_DEVID then
		tbt29_init=TBT29_WRONG_DEVID_REVISION
		goto leave
	end if

	'resolution :+0.25 C (tCONV = 65 ms typical)
	tbt29_write_data(TBT29_REG_RESOL,TBT29_RESOLUSION_MODE_1)
leave:

end function

function tbt29_get_c() as real
'Returns the signed floating point value expressing the temperature in deg. C.
	tbt29_get_c=tbt29_get()
	tbt29_get_c=tbt29_get_c/4
end function


function tbt29_get() as integer
'Returns the signed integer value expressing the temperature in 0.25 deg. C steps.	

	const DELAY_IN_65_MS=7
	dim r as word
	dim t_integer as word
	dim t_fraction as byte
	
	if tbt29_init_flag<>TBT29_INIT_SIGNATURE then

		exit function
	end if

	si2c_get(i2c_num_tbt29) 

	tbt29_delay_msecond(DELAY_IN_65_MS)

	r=tbt29_read_data(TBT29_REG_TA)

	if r and &h1000 then
		'temperature is negative
		t_integer=(r and &h0FFF)/16
		t_fraction=(r and &h000F)/4
		tbt29_get=1024-((t_integer*4)+t_fraction)
	else	
		'temperature is positive
		t_integer=(r and &h0FFF)/16
		t_fraction=(r and &h000F)/4
		tbt29_get=(t_integer*4)+t_fraction
	end if
end function

function tbt29_read_data(op as tbt29_regs) as word
	dim upper,lower as byte=0

	upper=0
	lower=0
	si2c_get(i2c_num_tbt29)
	si2c_start()

	'send address + op
	si2c_write(TBT29_WRITE_ADDR)
	si2c_write(op)
	
	si2c_start()

	si2c_write(TBT29_READ_ADDR)

	if op=TBT29_REG_RESOL then
		lower=si2c_read(true)
	else
		upper=si2c_read(true)
		lower=si2c_read(false)
	end if

	si2c_stop()
	tbt29_read_data=upper*256+lower
end function

sub tbt29_write_data(op as tbt29_regs,data as word)
	dim value as byte
	si2c_get(i2c_num_tbt29) 
	si2c_start()

	si2c_write(TBT29_WRITE_ADDR)
	si2c_write(op)

	if op=TBT29_REG_RESOL then
		value=data and &h00FF
		si2c_write(value)
	else
		value=(data and &hFF00)/256
		si2c_write(value)
		value=data and &h00FF
		si2c_write(value)		
	end if	
	si2c_stop()
end sub

sub tbt29_delay_msecond(value as word)

	sys.timercountms=0
	while sys.timercountms<value
	wend

end sub